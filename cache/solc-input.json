{
  "language": "Solidity",
  "sources": {
    "contracts/FlashProtocol.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.6.12;\n\nimport \"./interfaces/IFlashToken.sol\";\nimport \"./interfaces/IFlashReceiver.sol\";\nimport \"./interfaces/IFlashProtocol.sol\";\n\nimport \"./libraries/SafeMath.sol\";\nimport \"./libraries/Address.sol\";\n\ncontract FlashProtocol is IFlashProtocol {\n    using SafeMath for uint256;\n    using Address for address;\n\n    struct Stake {\n        uint256 amountIn;\n        uint256 expiry;\n        uint256 expireAfter;\n        uint256 mintedAmount;\n        address staker;\n        address receiver;\n    }\n\n    uint256 internal constant PRECISION = 1e18;\n    uint256 internal constant MAX_FPY_FOR_1_YEAR = 5e17;\n\n    uint256 internal constant SECONDS_IN_1_YEAR = 365 * 86400;\n\n    address public constant FLASH_TOKEN = address(0);\n\n    uint256 public matchRatio;\n    address public matchReceiver;\n\n    mapping(bytes32 => Stake) public stakes;\n    mapping(address => uint256) public balances;\n\n    event Staked(\n        bytes32 _id,\n        uint256 _amountIn,\n        uint256 _expiry,\n        uint256 _expireAfter,\n        uint256 _mintedAmount,\n        address indexed _staker,\n        address indexed _receiver\n    );\n\n    event Unstaked(bytes32 _id, uint256 _amountIn, address indexed _staker);\n\n    modifier onlyMatchReceiver {\n        require(msg.sender == matchReceiver, \"FlashProtocol:: NOT_MATCH_RECEIVER\");\n        _;\n    }\n\n    constructor(address _initialMatchReceiver) public {\n        _setMatchReceiver(_initialMatchReceiver);\n    }\n\n    function setMatchReceiver(address _newMatchReceiver) public onlyMatchReceiver {\n        _setMatchReceiver(_newMatchReceiver);\n    }\n\n    function _setMatchReceiver(address _newMatchReceiver) internal {\n        matchReceiver = _newMatchReceiver;\n    }\n\n    function setMatchRatio(uint256 _newMatchRatio) public onlyMatchReceiver {\n        require(_newMatchRatio >= 0 && _newMatchRatio <= 2000, \"FlashProtocol:: INVALID_MATCH_RATIO\");\n        matchRatio = _newMatchRatio;\n    }\n\n    function stake(\n        uint256 _amountIn,\n        uint256 _expiry,\n        address _receiver,\n        bytes calldata _data\n    )\n        public\n        override\n        returns (\n            uint256 mintedAmount,\n            uint256 matchedAmount,\n            bytes32 id\n        )\n    {\n        require(_amountIn > 0, \"FlashProtocol:: INVALID_AMOUNT\");\n\n        require(_receiver != address(this), \"FlashProtocol:: INVALID_ADDRESS\");\n\n        address staker = msg.sender;\n\n        require(_expiry <= calculateMaxStakePeriod(_amountIn), \"FlashProtocol:: MAX_STAKE_PERIOD_EXCEEDS\");\n\n        uint256 expiration = block.timestamp.add(_expiry);\n\n        IFlashToken(FLASH_TOKEN).transferFrom(staker, address(this), _amountIn);\n\n        balances[staker] = balances[staker].add(_amountIn);\n\n        id = keccak256(abi.encodePacked(_amountIn, _expiry, _receiver, staker, block.timestamp));\n\n        require(stakes[id].staker == address(0), \"FlashProtocol:: STAKE_EXISTS\");\n\n        mintedAmount = getMintAmount(_amountIn, _expiry);\n        matchedAmount = getMatchedAmount(mintedAmount);\n\n        IFlashToken(FLASH_TOKEN).mint(_receiver, mintedAmount);\n        IFlashToken(FLASH_TOKEN).mint(matchReceiver, matchedAmount);\n\n        stakes[id] = Stake(_amountIn, _expiry, expiration, mintedAmount, staker, _receiver);\n\n        if (_receiver.isContract()) {\n            IFlashReceiver(_receiver).receiveFlash(id, _amountIn, expiration, mintedAmount, staker, _data);\n        }\n\n        emit Staked(id, _amountIn, _expiry, expiration, mintedAmount, staker, _receiver);\n    }\n\n    function unstake(bytes32 _id) public override returns (uint256 withdrawAmount) {\n        Stake memory s = stakes[_id];\n        require(block.timestamp >= s.expireAfter, \"FlashProtol:: STAKE_NOT_EXPIRED\");\n        balances[s.staker] = balances[s.staker].sub(s.amountIn);\n        withdrawAmount = s.amountIn;\n        delete stakes[_id];\n        IFlashToken(FLASH_TOKEN).transfer(s.staker, withdrawAmount);\n        emit Unstaked(_id, s.amountIn, s.staker);\n    }\n\n    function unstakeEarly(bytes32 _id) public override returns (uint256 withdrawAmount) {\n        Stake memory s = stakes[_id];\n        address staker = msg.sender;\n        require(s.staker == staker, \"FlashProtocol:: INVALID_STAKER\");\n        uint256 remainingTime = (s.expireAfter.sub(block.timestamp));\n        uint256 burnAmount = _calculateBurn(s.amountIn, remainingTime, s.expiry);\n        assert(burnAmount <= s.amountIn);\n        balances[staker] = balances[staker].sub(s.amountIn);\n        withdrawAmount = s.amountIn.sub(burnAmount);\n        delete stakes[_id];\n        IFlashToken(FLASH_TOKEN).burn(burnAmount);\n        IFlashToken(FLASH_TOKEN).transfer(staker, withdrawAmount);\n        emit Unstaked(_id, s.amountIn, staker);\n    }\n\n    function getMatchedAmount(uint256 mintedAmount) public view returns (uint256) {\n        return mintedAmount.mul(matchRatio).div(10000);\n    }\n\n    function getMintAmount(uint256 _amountIn, uint256 _expiry) public view returns (uint256) {\n        return _amountIn.mul(_expiry).mul(getFPY(_amountIn)).div(PRECISION * SECONDS_IN_1_YEAR);\n    }\n\n    function getFPY(uint256 _amountIn) public view returns (uint256) {\n        return (PRECISION.sub(getPercentageStaked(_amountIn))).div(2);\n    }\n\n    function getPercentageStaked(uint256 _amountIn) public view returns (uint256 percentage) {\n        uint256 locked = IFlashToken(FLASH_TOKEN).balanceOf(address(this)).add(_amountIn);\n        percentage = locked.mul(PRECISION).div(IFlashToken(FLASH_TOKEN).totalSupply());\n    }\n\n    function _calculateBurn(\n        uint256 _amount,\n        uint256 _remainingTime,\n        uint256 _totalTime\n    ) private pure returns (uint256 burnAmount) {\n        burnAmount = ((_amount.mul(_remainingTime)).div(_totalTime));\n    }\n\n    function calculateMaxStakePeriod(uint256 _amountIn) private view returns (uint256) {\n        return MAX_FPY_FOR_1_YEAR.mul(SECONDS_IN_1_YEAR).div(getFPY(_amountIn));\n    }\n}\n"
    },
    "contracts/interfaces/IFlashToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\ninterface IFlashToken {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    function mint(address to, uint256 value) external returns (bool);\n\n    function burn(uint256 value) external returns (bool);\n}\n"
    },
    "contracts/interfaces/IFlashReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\ninterface IFlashReceiver {\n    function receiveFlash(\n        bytes32 id,\n        uint256 amountIn,\n        uint256 expireAfter,\n        uint256 mintedAmount,\n        address staker,\n        bytes calldata data\n    ) external returns (uint256);\n}\n"
    },
    "contracts/interfaces/IFlashProtocol.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\ninterface IFlashProtocol {\n    function stake(\n        uint256 _amountIn,\n        uint256 _days,\n        address _receiver,\n        bytes calldata _data\n    )\n        external\n        returns (\n            uint256 mintedAmount,\n            uint256 matchedAmount,\n            bytes32 id\n        );\n\n    function unstake(bytes32 _id)\n        external\n        returns (uint256 withdrawAmount);\n\n    function unstakeEarly(bytes32 _id)\n        external\n        returns (uint256 withdrawAmount);\n}\n"
    },
    "contracts/libraries/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\n// A library for performing overflow-safe math, courtesy of DappHub: https://github.com/dapphub/ds-math/blob/d0ef6d6a5f/src/math.sol\n// Modified to include only the essentials\nlibrary SafeMath {\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x, \"MATH:: ADD_OVERFLOW\");\n    }\n\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x, \"MATH:: SUB_UNDERFLOW\");\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"MATH:: MUL_OVERFLOW\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"MATH:: DIVISION_BY_ZERO\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n}\n"
    },
    "contracts/libraries/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": false
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers"
        ],
        "": [
          "id",
          "ast"
        ]
      }
    }
  }
}